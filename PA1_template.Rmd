# Reproducible Research: Peer Assessment 1

Sport Activity Analysis With Knitr
==================================

## Loading and preprocessing the data

Since the data has to be loaded from a zipped file, 
one would like to use unz().
This way the  html file can be attained by only running 
library(knitr) and knit2html("PA1_template.Rmd") from R.

```{r}
zipHandle<-unz("activity.zip", "activity.csv")
rawData<-read.table(zipHandle, header=TRUE, sep=",")
unlink(zipHandle)
rm(zipHandle)
```

As preprocessing the second column will be converted in a POSIXlt type.
Two other columns are also made in the right type 
and a dataframe is made from this.

```{r}
date<-as.POSIXct(rawData$date)
steps<-as.integer(rawData$steps)
interval<-as.character(rawData$interval)
df <- data.frame(date, interval, steps)
rm(rawData)
rm(date)
rm(interval)
rm(steps)
```

## What is mean total number of steps taken per day?
The dataframe from the file (called df) has one column with dates.
From this column a list of all the days the device was creating
data can be compiled.
Also the number of days the device was making data is determined.

```{r}

# first find out how many days the sensor was running
startDate<-df$date[1]
endDate<-df$date[length(df$date)]

# make a list containing the days on which the device was on
listOfDays = unique(df$date)

# calculate the number of days the device was on
numberOfDays = as.integer(length(listOfDays))

```

A for loop is used to evaluate for every day three required statistics, which are
* The mean of all the steps for one day.
* The sum of all the steps for one day.
* The median of all the steps for one day.

```{r}
# create a list on which we will append a mean for every
# run trough the for-loop
listOfMeans = as.numeric(matrix(NA, numberOfDays, 1))
listOfSums = as.numeric(matrix(NA, numberOfDays, 1))
listOfMedians = as.numeric(matrix(NA,numberOfDays,1))

# walk trough all the days and calculate properties for it
for ( daySelect in 1:numberOfDays)
{

    # subset only one day of the set
    dayData = subset(df, date == listOfDays[daySelect])

    # calculate the mean and sum for one day
    meanOfOneDay = mean(dayData$steps, na.rm = TRUE)
    sumOfOneDay = sum(dayData$steps, na.rm = TRUE)
    medianOfOneDay = median(dayData$steps, na.rm = TRUE)

    # write the new mean and sum in the list
    listOfMeans[[daySelect]] = meanOfOneDay
    listOfSums[[daySelect]] = sumOfOneDay
    listOfMedians[[daySelect]] = medianOfOneDay

}

```
For the report part, it is important to see that the interval is actually
registered every 5 minutes, thus the dimension of the mean table is in 
"average number of steps per 5 minutes", which is also the case for the median values.
The histogram is expressed in the total number of steps per day.
```{r}
# plot the histogram for the total number of steps
hLabel = "Histogram of the total number of steps per day"
hist(listOfSums, breaks = 10, xlab = "steps taken per day", main = hLabel)

# report the mean and median for the total steps taken every day
print(listOfMeans)
print(listOfMedians)

```

## What is the average daily activity pattern?

Calculating the average daily activity is essentially done in the same way as
calculating the mean for every day.
This time we iterate over all time intervals, and for every time interval we
will have to go along all days to fetch the number of steps.
This way we will find an array 

```{r}
# Make a list of all possible intervals, which are 12 per hour times 24 per day
listOfIntervals = unique(df$interval)
# Calculate the number of bins
numberOfIntervals = length(listOfIntervals)

# Array in which one element contains the number of steps for a specificInterval 
# Every index is one day.
listOfMeansInterval = as.numeric(matrix(NA, numberOfDays, 1))


# one has to start with 1
#intervalSelect = 1
for ( intervalSelect in 1:numberOfIntervals )
{

   # subset only one time interval of the set
   extractedTimeInterval = as.character(listOfIntervals[intervalSelect])
   intervalData = subset(df, df$interval == extractedTimeInterval)

   # calculate the mean and put it in the list of intervalMeans
   meanOfOneInterval = mean(intervalData$steps, na.rm = TRUE)

   # write the new mean in the list
   listOfMeansInterval[[intervalSelect]] = meanOfOneInterval

}

# Now we are actually done, however I want to find every interval for every
# selected interval

xplot = as.numeric(matrix(NA, numberOfIntervals, 1))
yplot = as.numeric(matrix(NA, numberOfIntervals, 1))

for ( intervalSelect in 1:numberOfIntervals)
{
    xplot[[intervalSelect]] = as.character(listOfIntervals[intervalSelect])
    yplot[[intervalSelect]] = listOfMeansInterval[[intervalSelect]]
}

# So now plot the figure
plot(xplot, yplot, xlab = "Time on day (interval)", ylab = "Steps per 5 minutes" ,type = "l")

```

The report part should find the peak in this graph, which is around 835, 
so maybe the person likes to walk every morning around 8:35.
Also he seems to never do any sport before 5 AM in the morning and after 20:00
in the evening.

## Imputing missing values



## Are there differences in activity patterns between weekdays and weekends?
